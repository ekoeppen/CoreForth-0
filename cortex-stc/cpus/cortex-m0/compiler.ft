\ vim:ft=forth:ts=2:sw=2:expandtab:foldmethod=marker:foldmarker=\\\ --\ ,\\\ ---:

\ -----------------------------------------------------------------------------
\ -- Compiler

: here          dp @ ;
: allot         here + dp ! ;
: org           dp ! ;
: ,             here ! cell allot ;
: h,            here h! 2 allot ;
: c,            here c! 1 allot ;

: [             false state ! ; immediate
: ]             true state ! ;
: ,call         here cell+ - >branch , ;
: literal       postpone lit , ; immediate
: execute       1+ >r ;

: len=          ( c-addr c-addr -- f ) c@ $3F and swap c@ $3F and = ;
: dict-compare  ( c-addr1 c-addr2 -- f )
                2dup len= 0= if 2drop 0 exit then
                swap 1+ swap count begin ?dup while
                  -rot 2dup ci@= 0= if 2drop drop 0 exit then
                  1+ swap 1+ rot 1-
                repeat 2drop -1 ;

\ -----------------------------------------------------------------------------
\ -- Control flow

: if            postpone ?branch here cell allot ; immediate
: else          postpone branch here cell allot here rot ! ; immediate
: then          here swap ! ; immediate
: begin         here ; immediate
: again         postpone branch , ; immediate
: until         postpone ?branch , ; immediate
: while         postpone ?branch here cell allot ; immediate
: repeat        swap postpone branch ,
                here swap ! ; immediate

: (do)          r> -rot >r 1- >r >r ;
: i             r> r> r@ -rot >r >r ;
: j             rp@ 4 cells + @ ;
: unloop        r> rdrop rdrop >r ;
: (loop)        r> r> r> 1+ 2dup < if 2drop true else >r >r false then
                swap >r ;
: do            postpone (do) here ; immediate
: loop          postpone (loop)
                postpone ?branch , ; immediate

: align         here aligned org ;
: imove         hmove ;
: link>name     6 + ;
: link>flags    4 + ;
: >body         $10 + ;
: link>         link>name dup c@ + 1+ aligned ;
: ,link         , ;
: find          >r latest begin
                  @ dup if dup link>name r@ dict-compare over current @ <> and
                  else r@ swap true
                  then
                until rdrop
                dup if
                  dup link>
                  swap link>flags c@ $FE <> 1 or
                then ;
: '             bl word find dup 0= if drop count type space $3F emit
                else drop then ;

: words         latest begin @ ?dup while
                  dup link>name count $3F and type space
                repeat ;
: list          latest begin @ ?dup while
                  dup link> u. dup link>name count $3F and type cr
                repeat ;

: <builds       align   here latest dup @ ,link  2 allot !
                bl word
                dup dup c@ 1+ here swap imove
                c@ 1+ allot align ;
: ,enter        $B500 h, ;
: ,exit         $BD00 h, ;
: immediate     $FE latest @ link>flags c! ;
: hide          latest @ current ! ;
: reveal        0 current ! ;
: postpone      bl word find 0< if literal postpone ,call
                else ,call then ; immediate
: [']           ' postpone literal ; immediate

: :             <builds ,enter hide ] ;
: ;             ,exit reveal [ ; immediate
: :noname       align latest @ here latest ! ]  , here ; immediate

: docon         $4902 h, $3E04 h, $6030 h, $0008 h, $46F7 h, ;
: dodata        $4679 h, $310C h, $3E04 h, $6030 h, $0008 h, $46F7 h, ;
: dodefer       $4900 h, $468F h, ;
: create        <builds dodata here , ;
: constant      <builds docon align , ;
: variable      <builds docon align vp dup @ dup , cell+ swap ! ;
: defer         <builds $46F7 h, 6 allot ; immediate
: defer!        swap 1+ swap cell+ ! ;
: is            ' $468F4900 over ! defer! ; immediate

: (does>)       here r> 1- latest @ link> #10 + org $B500 h, ,call org ;
: does>         postpone (does>) ; immediate
: recurse       latest @ link> ,call ; immediate
: [char]        char postpone literal ; immediate
\ : (             [char] ) word drop ; immediate
\ : \             source# @ >in ! ; immediate
: setbase       ( addr n -- addr' n' )
                over c@ dup 0<> and
                dup [char] $ = if drop $10 else
                dup [char] # = if drop $0A else
                    [char] % = if $02 else exit
                then then then base ! 1/string ;
: ?sign         ( addr n --  addr' n' f )
                over c@ $2C - dup abs 1 = and
                dup if 1+ >r 1/string r> then ;
: >number       ( u addr u --  u' addr' u' )
                setbase
                begin dup while
                  over c@ digit? 0= if drop exit then
                  >r rot base @ * r> + -rot
                  1/string
                repeat ;
: ?number       ( c-addr -- n -1 | c-addr 0 )
                base @ >r
                dup 0 0 rot count
                ?sign >r >number if rdrop 2drop drop 0
                else 2swap 2drop drop r> if negate then
                true then r> base ! ;
: (s")          r> 1- count 2dup + aligned 1+ >r ;
: s"            postpone (s")
                [char] " word dup dup c@ 1+ here swap imove
                c@ 1+ allot align ; immediate
\ : ."            postpone s" postpone type ; immediate

\ -----------------------------------------------------------------------------
\ -- Interpreter

: setup-pointers
                init-dp @ dp !
                init-vp @ vp !
                init-latest @ latest !
                ;

: prompt        [char] o emit [char] k emit cr ;
: source        (source) @ source# @ ;
: interpret     begin  bl word  dup c@ while      \ textadr
                  find ?dup if                    \ xt 1/-1
                    1+ state @ 0= or              \ immed or interp?
                    if execute else ,call then
                  else                            \ textadr
                    ?number if                    \ converted ok
                      state @ if postpone literal then
                    else count type [char] ? emit cr then  \ error
                  then
                repeat drop ;
: evaluate      source >r >r >in @ >r
                source# !  (source) ! 0 >in !  interpret
                r> >in ! r> source# ! r> (source) ! ;

: quit'         r0 rp! 0 state !    \ reset stacks, state
                setup-pointers
                s" CoreForth SE/Meta XXXXXXXX ready" type cr
                begin
                  xon
                  tib dup tib# accept space
                  xoff
                  evaluate
                  state @ 0= if space prompt then
                again ;

: refill        xon tib dup tib# accept space xoff
                source# ! (source) ! 0 >in ! true ;

: quit          r0 rp! 0 state !
                setup-pointers
                s" CoreForth Nemesis ready" type cr
                begin
                  refill
                while
                  interpret
                  state @ 0= if space prompt then
                repeat
                bye ;

: abort         s0 sp! #16 base ! quit ;
