\ vim:ft=forth:ts=2:sw=2:expandtab:foldmethod=marker:foldmarker=\\\ --\ ,\\\ ---:

\ -----------------------------------------------------------------------------
\ -- Compiler

variable state

$0040 constant immediate-flag
$0080 constant visible-flag

: here          dp @ ;
: allot         here + dp ! ;
: org           dp ! ;
: ,             here ! cell allot ;
: h,            here h! 2 allot ;
: c,            here c! 1 allot ;

: [             false state ! ; immediate
: ]             true state ! ;
: ,call         here cell+ - >branch , ;
: literal       postpone lit , ; immediate

: compiling?    state @ ;
: interpreting? state @ 0= ;
: execute       1+ >r ;

\ -----------------------------------------------------------------------------
\ -- Control flow

: if            postpone ?branch here cell allot ; immediate
: else          postpone branch here cell allot here rot ! ; immediate
: then          here swap ! ; immediate
: begin         here ; immediate
: again         postpone branch , ; immediate
: until         postpone ?branch , ; immediate
: while         postpone ?branch here cell allot ; immediate
: repeat        swap postpone branch ,
                here swap ! ; immediate

: (do)          r> -rot >r 1- >r >r ;
: i             r> r> r@ -rot >r >r ;
: j             rp@ 4 cells + @ ;
: unloop        r> rdrop rdrop >r ;
: (loop)        r> r> r> 1+ 2dup < if 2drop true else >r >r false then
                swap >r ;
: do            postpone (do) here ; immediate
: loop          postpone (loop)
                postpone ?branch , ; immediate

: align         here aligned org ;
: imove         hmove ;
: link>flags    4 + ;
: link>name     6 + ;
: >body         $10 + ;
: link>         link>name dup c@ + 1+ aligned ;
: ,link         , ;
: visible?      link>flags c@ visible-flag and 0= ;
: immediate?    link>flags c@ immediate-flag and 0= ;
: find          >r latest begin
                  @ dup if dup link>name r@ si= over visible? and
                  else r@ swap true
                  then
                until rdrop
                dup if
                  dup link>
                  swap immediate? not 1 or
                then ;
: '             bl word find dup 0= if drop count type space $3F emit
                else drop then ;

: words         latest begin @ ?dup while
                  dup link>name count type space
                repeat ;
: list          latest begin @ ?dup while
                  dup link> hex. space dup link>name count type cr
                repeat ;

: <builds       align   here latest dup @ ,link $FFFF h, !
                bl word
                dup dup c@ 1+ here swap imove
                c@ 1+ allot align ;
: ,enter        $B500 h, ;
: ,exit         $BD00 h, ;
: latest-flags  ( -- addr f ) latest @ link>flags dup c@ ;
: immediate     latest-flags immediate-flag invert and swap c! ;
: hide          latest-flags visible-flag or swap c! ;
: reveal        latest-flags visible-flag invert and swap c! ;
: postpone      bl word find 0< if literal postpone ,call
                else ,call then ; immediate
: [']           ' postpone literal ; immediate

: :             <builds ,enter hide ] ;
: ;             ,exit reveal [ ; immediate
: :noname       align latest @ here latest ! ]  , here ; immediate

: dodata        $4679 h, $310C h, $3E04 h, $6030 h, $0008 h, $46F7 h, ;
: dodefer       $4900 h, $468F h, ;
: create        <builds dodata here , reveal ;
: constant      <builds docon align , reveal ;
: variable      <builds docon align vp dup @ dup , cell+ swap ! reveal ;
: defer         <builds $46F7 h, 6 allot ; immediate
: defer!        swap 1+ swap cell+ ! ;
: is            ' $468F4900 over ! defer! ; immediate

: (does>)       here r> 1- latest @ link> #10 + org $B500 h, ,call org ;
: does>         postpone (does>) ; immediate
: recurse       latest @ link> ,call ; immediate
: [char]        char postpone literal ; immediate
: (             [char] ) word drop ; immediate
: \             source# @ >in ! ; immediate
: setbase       ( addr n -- addr' n' )
                over c@ dup 0<> and
                dup [char] $ = if drop $10 else
                dup [char] # = if drop $0A else
                    [char] % = if $02 else exit
                then then then base ! 1/string ;
: ?sign         ( addr n --  addr' n' f )
                over c@ $2C - dup abs 1 = and
                dup if 1+ >r 1/string r> then ;
: >number       ( u addr u --  u' addr' u' )
                setbase
                begin dup while
                  over c@ separator? if 1/string else
                  over c@ digit? if >r rot base @ * r> + -rot 1/string
                  else drop exit then then
                repeat ;
: ?number       ( c-addr -- n -1 | c-addr 0 )
                base @ >r
                dup 0 0 rot count
                ?sign >r >number if rdrop 2drop drop 0
                else 2swap 2drop drop r> if negate then
                true then r> base ! ;
: (s")          r> 1- count 2dup + aligned 1+ >r ;
: s"            postpone (s")
                [char] " word dup dup c@ 1+ here swap imove
                c@ 1+ allot align ; immediate
: ."            postpone s" postpone type ; immediate

\ -----------------------------------------------------------------------------
\ -- Interpreter

: prompt        [char] o emit [char] k emit cr ;
: source        (source) @ source# @ ;
: interpret     begin  bl word  dup c@ while      \ textadr
                  find ?dup if                    \ xt 1/-1
                    1+ interpreting? or              \ immed or interp?
                    if execute else ,call then
                  else                            \ textadr
                    ?number if                    \ converted ok
                      compiling? if postpone literal then
                    else count type [char] ? emit cr then  \ error
                  then
                repeat drop ;

: refill        xon tib dup tib# accept space xoff
                source# ! (source) ! 0 >in ! true ;

: quit          r0 rp! 0 state !
                \ s" CoreForth Nemesis ready" type cr
                begin
                  refill
                while
                  interpret
                  state @ 0= if space prompt then
                repeat
                bye ;

: abort         s0 sp! #16 base ! quit ;
