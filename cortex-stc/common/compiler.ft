\ vim:ft=forth:ts=2:sw=2:expandtab

variable state
variable dp
variable latest

$0040 constant immediate-flag
$0080 constant visible-flag

: here          dp @ ;
: allot         here + dp ! ;
: org           dp ! ;
: ,             here ! cell allot ;
: h,            here h! 2 allot ;
: c,            here c! 1 allot ;
: i,            dup h, #16 rshift h, ;
: i!            2dup h! swap #16 rshift swap 2+ h! ;

: [             false state ! ; immediate
: ]             true state ! ;
: ,call         here cell+ - >branch i, ;
: literal       postpone lit i, ; immediate

: compiling?    state @ ;
: interpreting? state @ 0= ;

: si=           ( c-addr1 c-addr2 -- f )
                dup c@ 1+ begin >r 2dup ci@= r> tuck and while
                  1- rot 1+ rot 1+ rot
                repeat -rot 2drop 0= ;

\ -----------------------------------------------------------------------------
\ -- Control flow

: if            postpone ?branch here cell allot ; immediate
: then          here swap ! ; immediate
: else          postpone branch here cell allot swap here swap ! ; immediate
: begin         here ; immediate
: again         postpone branch , ; immediate
: until         postpone ?branch , ; immediate
: while         postpone if swap ; immediate
: repeat        postpone branch , postpone then ; immediate

: (do)          r> -rot >r >r >r ;
: i             r> r> r@ -rot >r >r ;
: j             rp@ 4 cells + @ ;
: unloop        r> rdrop rdrop >r ;
: (loop)        r> r> r> 1+ 2dup = if 2drop true else >r >r false then
                swap >r ;
: (+loop)       r> r> r> 4 pick + 2dup = if 2drop true else >r >r false then
                swap >r ;
: do            postpone (do) here ; immediate
: loop          postpone (loop)
                postpone ?branch i, ; immediate
: +loop         postpone (+loop)
                postpone ?branch i, ; immediate
: leave         unloop rdrop ;

: align         here aligned org ;
: imove         hmove ;
: link>flags    4 + ;
: link>name     6 + ;
: >body         $10 + ;
: link>         link>name dup c@ + 1+ aligned ;
: ,link         i, ;
: visible?      link>flags c@ visible-flag and 0= ;
: immediate?    link>flags c@ immediate-flag and 0= ;
: find          >r latest begin
                  @ dup if dup link>name r@ si= over visible? and
                  else r@ swap true
                  then
                until rdrop
                dup if
                  dup link>
                  swap immediate? not 1 or
                then ;
: '             bl word find dup 0= if drop count type space $3F emit
                else drop then ;

: words         latest begin @ ?dup while
                  dup link>name count type space
                repeat ;
: list          latest begin @ ?dup while
                  dup link> hex. space dup link>name count type cr
                repeat ;

: <builds       align   here latest dup @ ,link $FFFF h, !
                bl word
                dup dup c@ 1+ here swap imove
                c@ 1+ allot align ;
: ,enter        $B500 h, ;
: ,exit         $BD00 h, ;
: latest-flags  ( -- addr f ) latest @ link>flags dup h@ ;
: immediate     latest-flags immediate-flag invert and swap h! ;
: hide          latest-flags visible-flag or swap h! ;
: reveal        latest-flags visible-flag invert and swap h! ;
: postpone      bl word find 0< if literal postpone ,call
                else ,call then ; immediate
: [']           ' postpone literal ; immediate

: :             <builds ,enter hide ] ;
: ;             ,exit reveal [ ; immediate
: :noname       align latest @ here latest ! ]  i, here ; immediate

: dodata        $4679 h, $310C h, $3E04 h, $6030 h, $0008 h, $46F7 h, ;
: docon         $F846 h, $0D04 h, $4800 h, $46F7 h, ;
: create        <builds dodata here i, reveal ;
: constant      <builds docon align i, reveal ;
: variable      <builds docon align vp dup @ dup i, cell+ swap ! reveal ;
: buffer:       <builds docon align vp dup @ dup i, rot + swap ! reveal ;
: defer         <builds $46F7 h, 6 allot reveal ; immediate
: defer!        swap 1+ swap cell+ i! ;
: is            ' $468F4900 over i! defer! ; immediate

: (does>)       here r> 1- latest @ link> #10 + org $B500 h, ,call org ;
: does>         postpone (does>) ; immediate
: recurse       latest @ link> ,call ; immediate
: [char]        char postpone literal ; immediate
: (             [char] ) word drop ; immediate
: \             source# @ >in ! ; immediate
: setbase       ( addr n -- addr' n' )
                over c@ dup 0<> and
                dup [char] $ = if drop $10 else
                dup [char] # = if drop $0A else
                    [char] % = if $02 else exit
                then then then base ! 1/string ;
: ?sign         ( addr n --  addr' n' f )
                over c@ $2C - dup abs 1 = and
                dup if 1+ >r 1/string r> then ;
: >number       ( u addr u --  u' addr' u' )
                setbase
                begin dup while
                  over c@ separator? if 1/string else
                  over c@ digit? if >r rot base @ * r> + -rot 1/string
                  else drop exit then then
                repeat ;
: ?number       ( c-addr -- n -1 | c-addr 0 )
                base @ >r
                dup 0 0 rot count
                ?sign >r >number if rdrop 2drop drop 0
                else 2swap 2drop drop r> if negate then
                true then r> base ! ;
: (s")          r> 1- count 2dup + aligned 1+ >r ;
: s"            postpone (s")
                [char] " word dup dup c@ 1+ here swap imove
                c@ 1+ allot align ; immediate
: ."            postpone s" postpone type ; immediate

\ -----------------------------------------------------------------------------
\ -- Interpreter

: ex.           $45 emit $23 emit h.4 ;
: prompt        source-id @ if exit then space [char] o emit [char] k emit cr ;
: interpret     begin  bl word  dup c@ while      \ textadr
                  find ?dup if                    \ xt 1/-1
                    1+ interpreting? or              \ immed or interp?
                    if execute else ,call then
                  else                            \ textadr
                    ?number if                    \ converted ok
                      compiling? if postpone literal then
                    else count type [char] ? emit cr $fff3 throw then
                  then
                repeat drop ;

: evaluate      source >in @ >r >r >r
                source# ! (source) ! 0 >in ! interpret
                r> r> r> >in ! source# ! (source) ! ;

: refill        xon tib dup tib# accept xoff
                source# ! (source) ! 0 >in ! true ;

: quit          r0 rp! 0 state ! 0 source-id !
                begin
                  refill
                while
                  source-id @ 0= if space then
                  ['] interpret catch
                  ?dup if
                    dup $fff3 <> if ex. else drop then
                    s0 sp!
                  then
                  interpreting? if prompt then
                repeat
                bye ;

: abort         s0 sp! #16 base ! quit ;
